# daemon off;
worker_processes 2;             # Rule of thumb: one per CPU (auto)
                                # Align with k8s spec.resources.limit.cpu
error_log  /proc/self/fd/2 warn;
pid        /var/lib/nginx/nginx.pid;

events {
    worker_connections  1024;   # Max concurrent connections per worker
    multi_accept on;            # Allow workers to accept all pending connections at once, rather than one by one
    use epoll;                  # Linux optimization
}

http {
    include /etc/nginx/mime.types;

    # Extract the left-most IP from X-Forwarded-For header (for rate limiting etc.)
    # Rely on Ingress to "trust" proxies
    map $http_x_forwarded_for $real_client_ip {

        # ^         Start of string
        # ()        Capture group
        #   [^,\s]  Any non-whitespace, non-comma character
        #   +       One or more such characters
        # $1        Return the first result

        ~^([^,\s]+) $1;
        default "";
    }

    # Nginx duplicates the X-Request-Id header, so extract the first value
    map $http_x_request_id $request_id_header {

        # ^         Start of string
        # ()        Capture group
        #   [^,\s]  Any non-whitespace, non-comma character
        #   +       One or more such characters
        # $1        Return the first result

        ~^([^,]+) $1;
        default "";
    }

    log_format debug '$request_id_header $time_iso8601 $request $status $upstream_status '

                # Client/Nginx Connection
                'c=$connection '                    # Connection serial number
                'cr=$connection_requests '          # Number of requests made on this connection
                'ct=$connection_time '              # Connection time (seconds)

                # Times
                'rt=$request_time '               # From first read to last byte sent

                # Request size
                'rl=$request_length '             # Request line + headers + body
                'cl=$http_content_length '        # Body (from Content-Length header)
                'ubs=$upstream_bytes_sent '       # FastCGI params + request body

                # Response size
                'bs=$bytes_sent '                 # Response bytes sent (status line + headers + body + HTTP/2 Frame Overhead)
                'bbs=$body_bytes_sent '           # Response body bytes sent

                '$http_referer "$http_user_agent" '
                ;

    access_log  /proc/self/fd/1 debug;

    # ephemeral storage
    client_body_temp_path /var/lib/nginx/tmp/client;
    fastcgi_temp_path     /var/lib/nginx/tmp/fastcgi;
    proxy_temp_path       /var/lib/nginx/tmp/proxy;
    scgi_temp_path        /var/lib/nginx/tmp/scgi;
    uwsgi_temp_path       /var/lib/nginx/tmp/uwsgi;

    # persistent storage
    # fastcgi_cache_path    /var/lib/nginx/cache/fastcgi levels=1:2 keys_zone=fastcgi_cache:10m inactive=60m;
    # proxy_cache_path      /var/lib/nginx/cache/proxy levels=1:2 keys_zone=proxy_cache:10m inactive=60m;

    # Rate Limiting
    # limit_req_zone $real_client_ip zone=req_api:10m rate=5r/s;      # Rate limiting                     503 Service Unavailable
    #                                                                 # 5 request/second --> 1 request allowed every 200ms (per IP)
    #                                                                 # 10MB / ~64b ≈ ~160,000 records (IP, last access time, excess counters, rate buckets)
    #                                                                 # burst: queue size for excess requests
    #                                                                 # nodelay: process queue instantly (but still fill the queue for the relevant time)

    limit_conn_zone $real_client_ip zone=conn_api:124k;             # Limit concurrent connections      503 Service Unavailable
                                                                    # 1MB / 64b ≈ 16,384 concurrent IPs / mb
                                                                    # Required memory = Max concurrent connections * 64b
                                                                    # = worker_processes * worker_connections * 64b
                                                                    # = 2 * 1024 * 64b = 124kb

    # Performance optimizations
    sendfile on;                # Lets Nginx send static files directly from disk
    tcp_nopush on;              # Send headers in one piece
    tcp_nodelay on;             # Don't buffer data-sends
    server_tokens off;          # Prevents Nginx revealing its version in error pages and `Server:` headers

    # Uploads
    client_max_body_size 512;   # Only serves GET requests                                      413 Request Entity Too Large    

    # Timeouts
    client_header_timeout 15s;      # Timeout for client to send request line & headers         408 Request Timeout             client timed out
    client_body_timeout 15s;        # Timeout for client to send body (incl. file upload)       408 Request Timeout             client timed out
    reset_timedout_connection on;   # Sends a TCP RST (reset) packet on `client_header_timeout` / `client_body_timeout`
                                    # Free up memory, file descriptors
    send_timeout 30s;               # Timeout for sending response to client                    504 Gateway Timeout             client was aborted

    # Client -> Nginx
    client_header_buffer_size 1k;       # Memory for request line & headers. If insufficient, use `large_client_header_buffers` instead
    large_client_header_buffers 4 4k;   # Larger memory for request line & headers. If exceeded 400 Bad Request                 client sent too large header  or  header too large
                                        # If a header line > client_header_buffer_size
                                        # and > large_client_header_buffers size then:          400 Bad Request / 414 URI Too Long
    client_body_buffer_size 512;        # Memory for request body. Excess to `client_body_temp_path`

    # HTTP compression
    gzip off;

    # Internal traffic (e.g. health-checks, Prometheus)
    server {
        listen 8081;
        listen [::]:8081;

        access_log off;

        keepalive_timeout 20s;   # Prometheus scrapes every 15 seconds
        keepalive_requests 5760; # 24 hours

        # Nginx health check
        location = /nginx-up {
            add_header Content-Type text/plain always;
            return 200 "up";
        }

        location /nginx-status {
            stub_status;
        }
    }

    # External traffic
    server {
        listen 8080;
        listen [::]:8080;

        root /usr/share/nginx/static;

        limit_conn conn_api 20;

        keepalive_timeout 60s;  # Max life of a keepalive connection
        keepalive_requests 100; # Max requests over a keepalive connection

        charset UTF-8;

        # Cache stat(), open() results for static assets
        open_file_cache max=50 inactive=365d;   # Max number of files       `find dist/ -type f | wc -l`
                                                # inactive: cache life
        open_file_cache_valid 365d;             # Cache lifetime
        open_file_cache_min_uses 1;             # Filter which files to cache
        open_file_cache_errors on;              # Cache file look-up error

        location = /robots.txt {
            access_log off;
            add_header X-Content-Type-Options "nosniff" always;                     # Global header
            add_header Cache-Control "public, max-age=3600" always;                 # Cache: 1 hour
            try_files $uri =404;
        }

        # Static assets (incl. favicon)
        # Consider other file extensions: sitemap.xml, manifest.json, humans.txt
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
            access_log off;
            add_header X-Content-Type-Options "nosniff" always;                     # Global header
            add_header Cache-Control "public, max-age=31536000, immutable" always;  # Cache: 1 year immutable
            try_files $uri =404;
        }

        location / {
            add_header X-Content-Type-Options "nosniff" always;                     # Global header
            add_header Cache-Control "no-cache, no-store, must-revalidate" always;  # Cache: none
            # HTML-specific headers
            add_header Referrer-Policy "strict-origin-when-cross-origin" always;
            add_header Content-Security-Policy "base-uri 'self'; form-action https://wh-api.ianf.dev; frame-ancestors 'none'; report-uri https://wh-api.ianf.dev/api/v1/csp-report; default-src 'none'; style-src 'self'; script-src 'self'; font-src 'self'; img-src 'self'; connect-src https://wh-api.ianf.dev;" always;
            add_header X-Frame-Options "DENY" always;                               # Pre-2015 browsers

            try_files /index.html =500;     # if index.html missing -> 403 Forbidden    directory index of "/usr/share/nginx/static/" is forbidden
        }
    }

    include /etc/nginx/conf.d/*.conf;
}

# Max memory per connection = client_header_buffer_size + large_client_header_buffers number * size + client_body_buffer_size
# Nginx overhead            = Master process overhead + workers * Worker process overhead + shared memory zones
# Shared memory zones       = proxy_cache_path + fastcgi_cache_path + limit_req_zone + limit_conn_zone + ssl_session_cache + sticky session zones

# Max total memory usage    = Max memory per connection * worker_connections * workers + Nginx overhead
#                           = (1k + 4*4k + 512) * 1024 * 2 + 10mb
#                           = 17920 * 1024 * 2 + 10mb
#                           = 36700160 + 10mb
#                           = 47185920
#                           = 45mb
